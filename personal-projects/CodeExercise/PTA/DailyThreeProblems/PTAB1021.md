# PTAB1021

```c++
//题目分析
//输入数据
大数;
getchar();
循环条件'\n';

//操作数据
//输出数据
D:M;
D升序输出;
定义一个数组,输入一个数遍历一遍数组,统计次数输出;
数组元素统计次数,数组下标当作数字;
count[9];
count[getchar()-'0']++;
遍历数组输出即可;
```

```c++
#include<iostream>
using namespace std;
int count[9];//等会注意一下这个数组能不能存下大数
int main(){
    char nums = '0';//这个类型的数据初始化是怎样的欸
    int number;
    while(nums != '\n'){
        nums = getchar();
        number = nums - '0';
        count[number]++;
    }
    for(int i = 0;i <= 9;i ++) cout<<i<<':'<<count[i];
    return 0;
}
```

![image-20211102151258239](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211102151258239.png)

[解决办法](https://stackoverflow.com/questions/11271889/global-variable-count-ambiguous)

![image-20211102151700541](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211102151700541.png)

知识点: `break`, `continue`应用不熟练

- break输出, 跳出整个循环

- continue跳出当前循环继续下一个循环

  ![image-20211102152911108](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211102152911108.png)

  

结尾无空行的格式化输出制定一个模板

```c++
//结尾无空行处理
知道第一项,不知道第二项,所以输出规律从第一项找;
设置判断条件前者比后者简洁;
#include<iostream>
int count[10];//等会注意一下这个数组能不能存下大数
int main(){
    int i = 0;
    char nums;//这个类型的数据初始化是怎样的欸
    int number;
    while((nums = getchar())!= '\n'){
        number = nums - '0';
        count[number]++;
    }
    std::cout<<i<<':'<<count[i];
    for(i = 1;i < 10;i ++){
    	if(count[i] != 0)
			std::cout<<std::endl<<i<<':'<<count[i];
		else
			continue;//不理解结尾无空行这种操作如何轻松处理,break和continue结果不一样
			//continue还要注意在if else中放的位置   	
	}
    return 0;
}
```

![image-20211102153838429](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211102153838429.png)

自己调试可以过, 但是出现段错误.

`count[9]`这个初始化有问题, 对数组定义理解的不够仔细

修改之后出现部分正确?

```c
//答案
#include <stdio.h>

int main()
{
    char c;
    int count[10] = {0};//这个初始化是相当于将全部元素都初始化了吗
    while((c = getchar()) != '\n')
        count[c - '0']++;

    for(int i = 0; i < 10; i++) if(count[i])
        printf("%d:%d\n", i, count[i]);

    return 0;
}
//为什么结尾有空行也可以过 为啥 为啥 我不理解
```

```c++
#include<iostream>

int count[10];
int main(){
    int i = 0;
    char nums;
    int number;
    int test[10] = {0};
    for(i=0;i<10;i++) 
    	std::cout<<"count:"<<count[i]<<std::endl;
		std::cout<<"test:"<<test[i]<<std::endl;
    
    while((nums = getchar())!= '\n'){
        number = nums - '0';
        count[number]++;
    }
    
    std::cout<<i<<':'<<count[i];
    for(i = 1;i < 10;i ++){
    	if(count[i])//条件简化count[i]
			std::cout<<std::endl<<i<<':'<<count[i];
		else
			continue;
	}
    return 0;
}
```

![image-20211102155535558](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20211102155535558.png)

不理解为什么输出是这样的 count在静态栈吗 为啥test会输出一个33 开始鬼畜了淦

```c++
//代码模仿
//结尾无空行处理
#include<iostream>
int main(){
    int count[10] = {0};
    char nums;//这个类型的数据初始化是怎样的欸
    while((nums = getchar())!= '\n'){
        count[nums - '0']++;
    }
    for(int i = 0;i < 10;i ++){
    	if(count[i])
			std::cout<<i<<':'<<count[i]<<std::endl;//注意这里也要修改
	}
    return 0;
}
//不能理解
```

